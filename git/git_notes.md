# Git Essentials
(mostly based on "Git Essentials for Beginners by Packt Publishing on O'Reilly)

---

## Terminology
**Git**
Is the local VCS on your machine

**Github**
The central system for hosting your files online for others to see and use with Git

---

## General Commands
```
#Shows history of commits
git log

#Initialize directory as git repository
git init /my_dir

#Shows detailed log of changes made since the last commit.
git diff

#Add and commit in a single command
git commit -am "commit message here"
```

---

## What is a Version Control System?
It tracks changes to a specific resource over time.
Things like Google Docs also have VCS, but slightly different.

The VCS works specifically not by saving all unique versions but by **tracking changes** - so a specific version can be generated by understanding all of the changes made since the original (similar to database change logs work).

Systems like Git work locally first - Git tracks changes on your computer to the files that you want tracked.
Most systems now also have a distributed system (e.g., GitHub) that allows all users to have the complete source code (clone), and a central server also has this source code. This allows greater durability of the code (in case of one computer crashing) and also allows collaboration.

## Very brief history of Git
Before 2005, BitKeeper was used by the Linux community - but then the free license was revoked which led to Git being developed.

## What is Git?
Git is for tracking changes in any set of files at speed. It is distributed and focuses on data integrity and supports non-linear workflows.

---

# Git Core Concepts

## Git architecture
**Working Directory**
Where we are working on the project by editing files.

**.git directory**
Inside the working directory- this stores information about your project (commit history, etc.) for git to use.
When we get information out of the .git directory into the working directory, it's called a `git checkout`

**Index / Staging area**
Inside the .git directory. When we ask git to put new changes into its database of changes, they are added to the staging area using `git add`.
Once we then want those staged changes to be durably written - and transferred from the staging area to the .git folder, we do a `git commit`.

**Remote server**
The remote git repository where files are stored and shared. We interact with this using `git clone`, `git fetch`, `git push`, and `git pull`.

## States of git workflow
1. When files are first edited, you are in the **modified** state.
2. When we use `git add` we stage the modifications we made - this is the **staged** state.
   1. *Note about staging:* I was originally confused about why we even needed a staging area, but [this article](https://githowto.com/staging_and_committing) explains it well. Essentially, staging allows us to customize our commits- staging only certain files in certain commits. In this way, we can make all of our commits make sense - the changes are 'packages' that hold together- rather than sporadic changes across all of the files.
3. Finally, our changes are in the **committed** state once we `git commit`.


## Hash Values (SHA-1)
Hashing is the process of transforming an input and creating an output such that:
- the output cannot be used to infer the input (cryptographically secure)
- the same input produces the same output
- reducing large data to a small, unique identifier

SHA-1 is a type of hashing algorithm that git uses for ensuring data integrity. In other words, this can be used to determine whether files have changed - if we send the same file to the hashing algorithm twice and it produces a different hash the 2nd time, it means the file was somehow changed.

## HEAD pointer
The HEAD pointer points to the latest commit of the current branch - just to keep track of our last progress.
When we initialize a repository, we get a default branch called 'main'. and the HEAD pointer points to the latest commit in the main branch.
When we create a new branch, our HEAD pointer points to the new branch.

The HEAD pointer is literally just a single file showing the hash of the latest commit in the .git directory.

## Move, Rename & Delete files
```
#Moving file "file1" to "subdir" folder
git mv file1.txt subdir/

#Renaming "file1" to "file2"
git mv file1.txt file2.txt
```

> **NOTE:** git mv is not magic. It's just shorthand for:
> ```
> mv oldname newname
> git add newname
> git rm oldname
> ```
> It is essentially **deleting the file and creating a copy in the new location.**
> But - we can still find the previous history of files by using `git log --follow ./filename`. This essentially includes both the
> history for the current file - and the history for the file that was deleted (renamed). This gives the practical effect of having
> full history for a single file, but git is tracking the files pre-rename and post-rename separately.
> For this reason, **it's a good idea to not rename your files too much** as it results in complicated git history.

## Dry runs
using the `--dry-run` option just lets us see a summary of what would happen - good if we aren't sure the best next step.
```
#Show what would happen if we staged all of our changes:
git add . --dry-run
```
---

# Reverting changes

## Rollback file changes
You can use `git restore ./my_file` to discard any changes for a particular file in your working directory. **Be careful you don't lost your changes - use with care!**

Once you have staged your files for commit with `git add` you can UNSTAGE those commits by using `git restore --staged ./myfile` - this will not remove changes to your files, but will just *unstage the changes.*

> **NOTE:** I like the idea of using `git add` as kind of a 'git save' option. As I'm working on my files, I can add my changes as I work. Then, once I make a *cohesive change*, I do a commit.
> If I need to roll back any changes

## Commit amend

## Commit revert

## Delete untracked files

---

# Extras

## Git Completion (optional)
Git completion is an optional - but handy tool that allows you to use the 'tab' key to auto-complete your git commands in the terminal.
Source code found here: https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
By copying this bash into our `/usr/share/bash-completion/completions` folder, we can get this file to run whenever we run a terminal - and therefore allow completion of our git commands.

```
#Download git completion file and save it in a random folder (made a bash_custom folder on home for convenience)
curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.bash_custom/.git-completion.bash
```

## Git Configuration
There are 3 levels of git configuration:
- System: `/etc/gitconfig`
  - We can set system config with `git config --system`
- User: `~/.config/git/config` or `~/.gitconfig`
  - We can set user config with `git config --global`
- Project: `.git/config`
  - We can set project config with `git config --local`

```
#List out user config:
git config --global -l

#List out project config:
git config --global -l

#List out all configurations:
git config -l
```

**Some commonly set configurations and what they mean:**
- user.email = what email will be used to sign off your git commits
- core.editor = base core editor. If you don't enter a commit message, for example, git will open this editor and ask you to enter the commit message there.

---

## Git commit messages best practices
Adding a sufficient level of detail to commit messages helps you navigate the commit log later on.
- Poor message: `"updated resources.txt file"`
  - This message says nothing about what changes were actually made - and git will already record which files were edited, so this adds no new information
- O.k. message: `"added 'fastAPI' and 'datetime' module dependencies to resources.txt file"`
  - This message says more specifically what we are doing - already making it easier to look through the commit log and see the flow of changes
- Good message: `"Jira#12003 added 'fastAPI' and 'datetime' module dependencies to resources.txt file"`
  - If we are working on a specific project or issue, we can and should reference the name of that in our commit - this makes it much easier to find and filter all of the commits related to specific tickets.
