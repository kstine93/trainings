# Git Essentials
(mostly based on "Git Essentials for Beginners by Packt Publishing on O'Reilly)

---

## Terminology
**Git**
Is the local VCS on your machine

**Github**
The central system for hosting your files online for others to see and use with Git

---

## General Commands
```
#Shows history of commits
git log

#Look at the log in a more visual way:
git log --online --decorate --graph

#Look at all logs
git log --all

#Initialize directory as git repository
git init /my_dir

#Shows detailed log of changes made since the last commit.
git diff

#Shows difference between a given commit and the previous commit (~1):
git diff 44c787d~1

#Add and commit in a single command
git commit -am "commit message here"

#Look at status of the repo in a simpler form:
git status -s

```

## General Tips:
- **Important: Don't push to your remote repo until you are 100% happy with your commit history, tagging, etc. It becomes harder to edit your commits once you `push`**

---

## What is a Version Control System?
It tracks changes to a specific resource over time.
Things like Google Docs also have VCS, but slightly different.

The VCS works specifically not by saving all unique versions but by **tracking changes** - so a specific version can be generated by understanding all of the changes made since the original (similar to database change logs work).

Systems like Git work locally first - Git tracks changes on your computer to the files that you want tracked.
Most systems now also have a distributed system (e.g., GitHub) that allows all users to have the complete source code (clone), and a central server also has this source code. This allows greater durability of the code (in case of one computer crashing) and also allows collaboration.

## Very brief history of Git
Before 2005, BitKeeper was used by the Linux community - but then the free license was revoked which led to Git being developed.

## What is Git?
Git is for tracking changes in any set of files at speed. It is distributed and focuses on data integrity and supports non-linear workflows.

---

# Git Core Concepts

## Git architecture
**Working Directory**
Where we are working on the project by editing files.

**.git directory**
Inside the working directory- this stores information about your project (commit history, etc.) for git to use.
When we get information out of the .git directory into the working directory, it's called a `git checkout`

**Index / Staging area**
Inside the .git directory. When we ask git to put new changes into its database of changes, they are added to the staging area using `git add`.
Once we then want those staged changes to be durably written - and transferred from the staging area to the .git folder, we do a `git commit`.

**Remote server**
The remote git repository where files are stored and shared. We interact with this using `git clone`, `git fetch`, `git push`, and `git pull`.

## States of git workflow
1. When files are first edited, you are in the **modified** state.
2. When we use `git add` we stage the modifications we made - this is the **staged** state.
   1. *Note about staging:* I was originally confused about why we even needed a staging area, but [this article](https://githowto.com/staging_and_committing) explains it well. Essentially, staging allows us to customize our commits- staging only certain files in certain commits. In this way, we can make all of our commits make sense - the changes are 'packages' that hold together- rather than sporadic changes across all of the files.
3. Finally, our changes are in the **committed** state once we `git commit`.


## Hash Values (SHA-1)
Hashing is the process of transforming an input and creating an output such that:
- the output cannot be used to infer the input (cryptographically secure)
- the same input produces the same output
- reducing large data to a small, unique identifier

SHA-1 is a type of hashing algorithm that git uses for ensuring data integrity. In other words, this can be used to determine whether files have changed - if we send the same file to the hashing algorithm twice and it produces a different hash the 2nd time, it means the file was somehow changed.

## HEAD pointer
The HEAD pointer points to the latest commit of the current branch - just to keep track of our last progress.
When we initialize a repository, we get a default branch called 'main'. and the HEAD pointer points to the latest commit in the main branch.
When we create a new branch, our HEAD pointer points to the new branch.

The HEAD pointer is literally just a single file showing the hash of the latest commit in the .git directory.

## Move, Rename & Delete files
```
#Moving file "file1" to "subdir" folder
git mv file1.txt subdir/

#Renaming "file1" to "file2"
git mv file1.txt file2.txt
```

> **NOTE:** git mv is not magic. It's just shorthand for:
> ```
> mv oldname newname
> git add newname
> git rm oldname
> ```
> It is essentially **deleting the file and creating a copy in the new location.**
> But - we can still find the previous history of files by using `git log --follow ./filename`. This essentially includes both the
> history for the current file - and the history for the file that was deleted (renamed). This gives the practical effect of having
> full history for a single file, but git is tracking the files pre-rename and post-rename separately.
> For this reason, **it's a good idea to not rename your files too much** as it results in complicated git history.

## Dry runs
using the `--dry-run` option just lets us see a summary of what would happen - good if we aren't sure the best next step.
```
#Show what would happen if we staged all of our changes:
git add . --dry-run
```
---

# Reverting changes

## Rollback file changes
You can use `git restore ./my_file` to discard any changes for a particular file in your working directory. **Be careful you don't lost your changes - use with care!**

Once you have staged your files for commit with `git add` you can UNSTAGE those commits by using `git restore --staged ./myfile` - this will not remove changes to your files, but will just *unstage the changes.*

> **NOTE:** I like the idea of using `git add` as kind of a 'git save' option. As I'm working on my files, I can add my changes as I work. Then, once I make a *cohesive change*, I do a commit.
> If I need to roll back any changes, I can just do a `git restore` on a single file, but I know that it's extra difficult for me to accidentally revert all changes - because I can't revert already staged changes without the --staged option.

## Commit amend
The `git commit --amend` command allows you to add changes to the last commit and update the message. This REPLACES the last commit.
```
git commit --amend -m "added dependencies AND config file"
```

> **NOTE:** When would I want to do this? I guess if I made an actual error with my previous commit, that would be helpful,
> or if I forgot to add some relevant changes to the same commit.

> **NOTE:** Git recommends that you make *relatively small changes* - which are easily rolled back - rather than large, monolithic commits. I'm guessing there's a sweet spot - enough changes so that it's impactful, not so many that it's too big of a single step.

## Commit revert
Reverting the latest commit is relatively easy, but reverting older commits is more difficult.

## Delete untracked files
`git clean` allows you to remove files only if they are **untracked**. It also works recursively for all folders in the git repo. The `-n` option does a dry run, `-f` (force) executes the removal, and `-i` is interactive (more options also exist).

This is convenient relative to `rm` since it (a) works recursively for all folders in a git repo and (b) only removes untracked files.
There may be other advantages too that I'm not yet aware of.

---

# Ignoring files
We want to ignore temporary, sensitive, or infrastructure-related (e.g., virtual envs) files.

## Ignore files
### .gitignore syntax
```
#This is a comment in .gitignore file
#---------------
#--Directories--
#---------------
#Ignore everything in the 'media' folder
media/

#------------------
#--Specific files--
#------------------
*test.mp4

#------------------------
#--Matching expressions--
#------------------------
#Ignore any file ending in '.log'
*.log

#------------
#--Negation--
#------------
#Ignore all log files as specified above, except 'security.log'
!security.log
```

### Ignoring on system or user level;
```
#Make a gitignore file on the system level:
git config --global core.execluesgfile ~/.gitignore_all
```
> NOTE: I don't like the idea of setting too many global values like this - because these other specifications are not being tracked. For example, if I popped down on a new computer and cloned the repo, then I would need to re-set those system-level specs. I think that's not as nice as having every repo be self-contained: having 100% of the information necessary to run and maintain the code.

## Track empty folders
By default, git does **not** track empty folders. Some people (apparently including the trainer of this course) want all of their empty folders to also be tracked. If you want this, you just need to add some dummy file (e.g., an empty `.trackme` file) to the folder and then git will track it.

> I personally much use for this. Git is not for tracking folder structures anyway (as evidenced by its clunky renaming system), and if a folder is empty, I don't see why we need it. Maybe one exception would be if I am collaborating with others and I want to set up a repo structure for us all to use, then I would want to upload the structure. I would definitely use a non-hidden file though (e.g., `dummy-file.txt`)

## Untrack tracked files
Once you track a file in git, it's a little tricky to *stop tracking it*.
The first step is to identify the file in `.gitignore`, but that alone will not stop it from being tracked.
You will also need to remove it from the git cache using `git rm --cached file.txt`. This will keep the file locally, but git will no longer track it.

---

# Git Branches
Git branches are pretty easy to create (relative to other VCS's) and switch between.

## Creating branches
```
# List out branches
git branch

# Create branch
git branch feature_1

# Switch branches
git checkout feature_1

# Create + switch to branch in 1 command
git checkout -b feature_1
```

> NOTE: As you switch between branches, the files in your local directory will update on-the-fly with the latest commit for that particular branch. This makes sense, but it's also a bit surprising to have git modifying your files for you.

## Renaming branches
We would rename branches if we made a mistake or we want to take a previously development branch and make it production
`git branch -m old_branch_name new_branch_name`
A typical professional branch name might be embedded with additional information like: **release_1.1.0_paymentoverhaul**

## Deleting branches
```
#Show which branches are merged into the currently active branch
#If more than 1 branch is shown, we know which branches are fully merged (and could be deleted without losing content)
git branch --merged

#Delete a branch
#If you try to do this with an unmerged branch, you will get a warning when doing this.
git branch -d old_branch
```

## Merging
```
#Compare differences between 2 branches:
git diff branch_1 branch_2

#Merge a given branch into the branch you're currently on.
git merge branch_2
```

> Note: The trainer noted that merging is only easy when the same files are not being edited by 2 different branches - *but this is rarely the case.* Resolving different changes in the same file across branches can be tricky - so the following practices are recommended:
>  1. Pull the latest updates from your primary (production) branch into your branch whenever you start working and before you attempt to merge your branch with the primary branch. Resolve issues locally.
>  2. [Microsoft recommends using feature branches](https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance?view=azure-devops) for all of your bug fixes and new features. They say that since branches are so easy to create and maintain, this is well worth the effort.
>  3. Microsoft also recommends holding to a naming convention for feature branches [such as using folders](https://learn.microsoft.com/en-us/azure/devops/repos/git/require-branch-folders?view=azure-devops&tabs=browser) and insisting on pull requests for reviewing changes and ensuring code quality.

---

# Git tags
Tags are just names associated with specific commits in the repository. This allows us to find them later rather than relying only on commit hashes. For instance, if we have used tags in our commits, and we use `git log` - we will see the tags alongside our commit log and it will be easier to see which commits are related to certain features, bugfixes, etc.

1. Lightweight tags point to a commit hash. This has no meta data
2. Annotated tags also have *meta data* (author's name, release notes, tag-message, date, etc.) and is the preferred tag for public releases.

**NOTE: git tags can only be used once.** A good comparison is chapter titles: you wouldn't use the same one twice. For that reason, **semantic versioning** is often used as a git tagging concept. An application of this would be if we needed to somehow roll back to the last stable version, we could easily identify in our git logs which was the last version because that commit is **tagged as such.**

## Create and list tags
```
#Create a *lightweight* tag
git tag release_tag_v1

#Create an *annotated* tag
git tag -a release_tag_v1

#List tags
git tag

#List tags starting with "rel"
git tag -l rel*

#VERY COOL: Assign a tag to a past commit (do some cleaning of your git history after the fact to make it more manageable).
#End of the line is the start of the commit hash:
git tag -a practice_tag_2 a0d354b
```

Note: everytime you create a tag, it gets assigned to the HEAD of the current branch.

## Delete tags
`git tag -d release_1.0.1`

## Checkout tags & detached HEAD
If you run the command `git checkout` with either a tag name or a commit hash (i.e., some way to identify the commit), then you will start to see and edit files as if you were *on that past commit*. At this stage, you are **not on a branch** - which means you are in a 'detached head' state.
Git tells you once you run this command more about this, but essentially you can play around with making changes and easily discard them, but if you want to actually commit changes, you will need to create a new branch off of this commit that you've checked out.

The danger of working like this is that **if you switch out of this detached head state then all of your commits could be lost**. More specifically, git will warn you that you're leaving some commits behind and give you the hash, but if you don't record this for some reason, you will not be able to find this commit hash - and the commit - later.

---

# Git aliases
These are similar to linux aliases - they're ways to create shortened commands:
```
#Create an alias 's' for 'git status'
git config --global alias.s status

#git status:
git s
```

> Note: I don't hate this, but I'm not sure it's worth it, unless it's for a particularly complex and often-used command (e.g., with lots of options)

> Bonus: Linux Aliases:
> `alias` will show the linux aliases I have in my system.
> `alias gl="git log --oneline"` will make an alias 'gl' to run 'git log'

---

# Remote repo + Commit log filtering

## Cloning a remote repo
```
#Clone a specific git repo:
git clone https://github.com/git/git.git
```

Note: When cloning a repo, use `git log` and `git tag` to find and explore the past commits.

---

## Git log filtering
```
#Get the last 3 commits
git log -3

#Get all commits UP UNTIL a particular tag
git log rel1.0

#Display all commits by authors matching "Kevi"
git log --author="Kevi"

#Find all commits with messages matching 'notes'
git log --oneline --grep="notes"

#Find all commits from commit 'a38c8a3' until current commit (HEAD)
git log --oneline a38c8a3..HEAD

#Find all commits from commit 'a38c8a3' until commit '7b543cc'
git log --oneline a38c8a3..7b543cc

#Find all commits made after April 1, 2023 and before April 21, 2023:
git log --oneline --after="2023-04-01" --before="2023-04-21"
```

## Git log + format options:
```
#Print a shorter git log:
#Other options: full, fuller, raw
git log --format=short

#Print a git log with user emails:
git log --format=email

#Show a visual graph of branches
git log --graph
```

---

# Git Merging
When we have multiple branches, we can run into conflicts where changes to one branch are in conflict with changes to another.

## Merging strategies
**Fast Forward**
A fast-forward merge is a merge where there have been no changes on one of the branches since they split - so there is no chance for any conflicts. These are typically used for short-lived branches (long-lived branches typically can't escape conflicts).
With fast-forward merges, **no extra commit is made.**
`git merge --ff-only`

**3-Way Merge**
A 3-way merge is a typical merge: where we merge 2 branches that both have had commits made on them since they split from each other.
> *Note: If you edit DIFFERENT FILES on the two branches, then there should be no conflicts*. It's only when you have edits to the same file that you have conflicts.

---

## Merge conflicts
If we try to merge 2 branches that have different changes to the same file, we run into a merge conflict.
When this happens, we have a sort of 'intermediate' commit that is not fully finished - it edits our conflicting files with some markup language to show us what changes come from one branch or the other.
With merge conflicts, **you must edit these files again and resolve thse conflicts manually**. You can simply edit these files, removing the markup, and create the final version that you want.

This can really scale up when you have lots of conflicting files - another reason to have smaller branches that have few conflicts rather than big branches that might have a lot of conflicts.

---

# Branching

## Branching strategies
**Long-running branches**
Long-running branches are branches like "Main" or "Dev" or "Feature" - they are workspaces used to separate development streams. Long-running branches are rarely deleted because their application is an element of the development cycle rather than being related to the actual codebase.
Other common long-running branch applications:
- Quality Assurance Branch
- Staging branch
- Load testing branch
- etc.

**Topic branches**
Topic branches are created only for a specific topic, like a hotfix or issue - they are to achieve some finite goal and are typically short-lived (merged and deleted once the topic is complete).

---

# Stashing
Stashing is a way to store staged changes you have made (but not committed) before you move the HEAD to another branch or a previous commit.
This is useful in case you don't want to commit yet, but you aren't willing to erase your changes when you move the HEAD without committing.

> Note that stashed changes are available for any branch- they are branch-agnostic.

You can also stash multiple times - which will create a stash stack of multiple stashes that you can work with.

> Note also that git will only force you to stash if you are switching to a previous commit in the same branch OR the branch you are switching to has diverged from the branch you are on (i.e., the commit HEAD is pointing to represents a  different state of the repo).

## Stashing & reviewing list
```
#Move the changes you've just made into stash:
git stash

#List all the stashes you have:
git stash list

#Stash your changes with a comment message:
git stash save "changed file x with details y"

#Pop off the last stash you made and restore the changes to the repo.
#NOTE: THIS ALSO REMOVES THE STASH
git stash pop

#Restore the changes from the latest stash, but DO NOT REMOVE THE STASH
git stash apply

#Apply a specific stash from the stash stack:
git stash apply stash@{1}

#Remove a specific stash from the list
#WARNING: THIS PERMANENTLY DELETES YOUR STASHED CHANGES:
git stash drop stash@{1}

#Remove all stashes
#WARNING: THIS PERMANENTLY DELETES ALL STASHED CHANGES:
git stash clear
```

## Selectively stashing changes
```
#Open an interactive session to handle different hunks in your code - and stash them or not
#In this interactive session, enter `?` to list out options for each hunk
git stash --patch
```

## Creating a branch with a stash
After you have stashed some changes, you can pop these stashed changes into a new branch with:
`git stash branch branch_name`

---

# Rebasing
Rebasing is when we change where the 'split' between two branches exists.
This helps make the commit history more linear - this has benefits when diving into the commit log later [more info here](https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase).

Take the git log graph below. We have 2 branchs 'A' and 'B'.
With rebasing 'B' from 'A', we keep both branches, but the 'B' branch now contains all updates up to the latest commit from the 'A' branch.
With rebasing 'A' from 'B', the commit chains of both branches essentially become one- and both branches have the same history.

> **Note:** I actually don't understand the difference in 'directionality' with rebasing. Git is not keeping track of which was the 'original' branch, is it? So why would it matter to git if we do 'A' from 'B' or 'B' from 'A'?
_____________________________________________
Original  | Rebase B from A | Rebase A from B
          |                 |
          |     B           |  A,B
          |     o           |   o
  B       |     |           |   |
  o       |   A o           |   o
A |       |    /            |   |
o o       |   o             |   o
|/        |   |             |   |
o         |   o             |   o

**Drawbacks of rebasing**
- "Not suitable for large projects with many developers" - why not?
- "Requires development team to adhere to certain rules" - like what?

**Tips & Tricks**
- [Atlassian](https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase) tips:
  -  doesn't recommend rebasing commits if you've already pushed them to a public repository because the rebase **replaces those commits** and so it would appear that part of the project history vanished.
  -  recommends using the interactive `-i` flag when rebasing as it allows you to "squash" and get rid of insignificant commits. This can keep the public commit history simple and meaningful - with no silly commits when I messed things up and had to revert a commit...
     -  **another reminder to NOT PUSH TO REMOTE REPO UNTIL I'M HAPPY WITH MY COMMIT HISTORY**
  -  REBASE **FREQUENTLY** - particularly if you have a long-lived branch. Otherwise your branch will divert from its base branch significantly and when you finally merge it there could be a huge number of conflicts to resolve.


## git pull + rebasing
`Git pull` copies the remote repository code to your local machine. If you are working on your feature branch in a local copy and in the meantime the remote repository advances in its commit history, you can use `git pull` to first download the latest commits from the remote repository, and then use `git rebase` to move your feature branch to the end of the master branch that you just downloaded. This allows you to resolve any conflicts and merge on your local machine.

## My personal understanding of rebasing
Rebasing to me appears to be an alternative to **merging**. If we have 2 branches with differing commits, the commit conflicts must be resolved if we want to consolidate changes into a single new version. Whether we do this with merging or rebasing has implications for the commit history, but the code will still pop out the same.

Merging consolidates differences into 1 version by having a new commit in which 2 branches are combined - and any conflicts are resolved there. This results in a git history where a branch diverges and comes back in - the branch is preserved along with the individual commits that were formed on that branch instead of the 'main' branch.

Rebasing consolidates differences into 1 version by smoothing over the complex branch history - it rewrites the past history to reduce conflicts before merging ever happens. So with 2 branches that need combining, rebasing will either make it look like the branch never diverged at all OR that nothing has happened on the 'main' branch after the branch diverged. In the former case, no merging is necessary. In the latter case, merging is simply a fast-forward operation.

## Interactive rebasing
Interactive rebasing lets us do a lot more than automatic rebasing, including:
- updating past commit messages
- Change past commits
- Reorder commits
- Combine multiple past commits into 1 commit (e.g., if the old commits are too granular)

```
#Rebase working within the last 3 commits:
git rebase -i HEAD~3
```
Running the command above opens a temporary file that looks like this:
```
pick a31c670 more git notes
pick 4418284 More git notes
pick 37a3d72 even more git notes

# Rebase a0ef6db..37a3d72 onto a0ef6db (3 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup [-C | -c] <commit> = like "squash" but keep only the previous
#                    commit's log message, unless -C is used, in which case
#                    keep only this commit's message; -c is same as -C but
#                    opens the editor
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified); use -c <commit> to reword the commit message
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
```
The first 3 lines with "pick" are the commits that we're rebasing.
We can edit these lines - using the character commands listed in the comments - to specify how we want to rebase.

---

# Git Search
We can search through our entire git repo for specific text using the `git grep` commmand.
- **Note:** This is also possible with the linux terminal, but I'm not sure yet how or where it searches. Check this out later.
- **Note:** I can imagine that this would be SUPER helpful for identifying dependencies (e.g., where am I referencing my submodule that I just updated?)

```
#Search for the string "latter" in our current git repo
git grep latter

#Search for 'latter' again, but ignore case
git grep -i latter

#Show the line number where you found the match:
git grep -n latter

#Just show the files where you find a match - not the contents:
git grep -l latter

#Just count the number of times that the text appears in each file:
git grep --count latter

#Search only within '.txt' files:
git grep latter *.txt

#Find files with the text "latter" or "submodule"
git grep -E "latter|submodule"

```

## Searching commit history
`git grep` doesn't work that much differently than Linux's default `grep` command - except that `git grep` can **also search through past commits.**

```
# Search for the text "dbt" in the repo at the time of the previous commit "8bf1081"
git grep dbt 8bf1081

# Search for the text "dbt" in the repo that is 4 commits previous from HEAD
git grep dbt HEAD~4

# Search for the text "dbt" in 2 commits: the one 4 commits previous from HEAD, and the one 6 commits previous from the 8bf1081 commit
git grep dbt HEAD~4 8bf1081~6

# Search for text "dbt" within the branch "test_branch"
git grep dbt test_branch

# Search for the function or class name in which the code "testVar = 34" is written:
git grep -p "testVar = 34"
```

---

# Commit history: rewrite and reset

## Updating commit messages
As we've covered in another section, `git commit --amend` lets you edit the last commit and change its message.
However, this command **also** lets you add any new staged changes you have to the last commit. So the last commit is very fluid - you can update the message and the changes as you like.

## Reordering commits

## Drop commits

## Squashing commits

## Git reset

---

# Extras

## Git Completion (optional)
Git completion is an optional - but handy tool that allows you to use the 'tab' key to auto-complete your git commands in the terminal.
Source code found here: https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
By copying this bash into our `/usr/share/bash-completion/completions` folder, we can get this file to run whenever we run a terminal - and therefore allow completion of our git commands.

```
#Download git completion file and save it in a random folder (made a bash_custom folder on home for convenience)
curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.bash_custom/.git-completion.bash
```

## Git Configuration
There are 3 levels of git configuration:
- System: `/etc/gitconfig`
  - We can set system config with `git config --system`
- User: `~/.config/git/config` or `~/.gitconfig`
  - We can set user config with `git config --global`
- Project: `.git/config`
  - We can set project config with `git config --local`

```
#List out user config:
git config --global -l

#List out project config:
git config --global -l

#List out all configurations:
git config -l
```

**Some commonly set configurations and what they mean:**
- user.email = what email will be used to sign off your git commits
- core.editor = base core editor. If you don't enter a commit message, for example, git will open this editor and ask you to enter the commit message there.

---

## Git commit messages best practices
Adding a sufficient level of detail to commit messages helps you navigate the commit log later on.
- Poor message: `"updated resources.txt file"`
  - This message says nothing about what changes were actually made - and git will already record which files were edited, so this adds no new information
- O.k. message: `"added 'fastAPI' and 'datetime' module dependencies to resources.txt file"`
  - This message says more specifically what we are doing - already making it easier to look through the commit log and see the flow of changes
- Good message: `"Jira#12003 added 'fastAPI' and 'datetime' module dependencies to resources.txt file"`
  - If we are working on a specific project or issue, we can and should reference the name of that in our commit - this makes it much easier to find and filter all of the commits related to specific tickets.
