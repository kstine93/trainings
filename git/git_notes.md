# Git Essentials
(mostly based on "Git Essentials for Beginners by Packt Publishing on O'Reilly)

---

## Terminology
**Git**
Is the local VCS on your machine

**Github**
The central system for hosting your files online for others to see and use with Git

---

## General Commands
```
#Shows history of commits
git log

#Look at the log in a more visual way:
git log --online --decorate --graph

#Look at all logs
git log --all

#Initialize directory as git repository
git init /my_dir

#Shows detailed log of changes made since the last commit.
git diff

#Add and commit in a single command
git commit -am "commit message here"

```

---

## What is a Version Control System?
It tracks changes to a specific resource over time.
Things like Google Docs also have VCS, but slightly different.

The VCS works specifically not by saving all unique versions but by **tracking changes** - so a specific version can be generated by understanding all of the changes made since the original (similar to database change logs work).

Systems like Git work locally first - Git tracks changes on your computer to the files that you want tracked.
Most systems now also have a distributed system (e.g., GitHub) that allows all users to have the complete source code (clone), and a central server also has this source code. This allows greater durability of the code (in case of one computer crashing) and also allows collaboration.

## Very brief history of Git
Before 2005, BitKeeper was used by the Linux community - but then the free license was revoked which led to Git being developed.

## What is Git?
Git is for tracking changes in any set of files at speed. It is distributed and focuses on data integrity and supports non-linear workflows.

---

# Git Core Concepts

## Git architecture
**Working Directory**
Where we are working on the project by editing files.

**.git directory**
Inside the working directory- this stores information about your project (commit history, etc.) for git to use.
When we get information out of the .git directory into the working directory, it's called a `git checkout`

**Index / Staging area**
Inside the .git directory. When we ask git to put new changes into its database of changes, they are added to the staging area using `git add`.
Once we then want those staged changes to be durably written - and transferred from the staging area to the .git folder, we do a `git commit`.

**Remote server**
The remote git repository where files are stored and shared. We interact with this using `git clone`, `git fetch`, `git push`, and `git pull`.

## States of git workflow
1. When files are first edited, you are in the **modified** state.
2. When we use `git add` we stage the modifications we made - this is the **staged** state.
   1. *Note about staging:* I was originally confused about why we even needed a staging area, but [this article](https://githowto.com/staging_and_committing) explains it well. Essentially, staging allows us to customize our commits- staging only certain files in certain commits. In this way, we can make all of our commits make sense - the changes are 'packages' that hold together- rather than sporadic changes across all of the files.
3. Finally, our changes are in the **committed** state once we `git commit`.


## Hash Values (SHA-1)
Hashing is the process of transforming an input and creating an output such that:
- the output cannot be used to infer the input (cryptographically secure)
- the same input produces the same output
- reducing large data to a small, unique identifier

SHA-1 is a type of hashing algorithm that git uses for ensuring data integrity. In other words, this can be used to determine whether files have changed - if we send the same file to the hashing algorithm twice and it produces a different hash the 2nd time, it means the file was somehow changed.

## HEAD pointer
The HEAD pointer points to the latest commit of the current branch - just to keep track of our last progress.
When we initialize a repository, we get a default branch called 'main'. and the HEAD pointer points to the latest commit in the main branch.
When we create a new branch, our HEAD pointer points to the new branch.

The HEAD pointer is literally just a single file showing the hash of the latest commit in the .git directory.

## Move, Rename & Delete files
```
#Moving file "file1" to "subdir" folder
git mv file1.txt subdir/

#Renaming "file1" to "file2"
git mv file1.txt file2.txt
```

> **NOTE:** git mv is not magic. It's just shorthand for:
> ```
> mv oldname newname
> git add newname
> git rm oldname
> ```
> It is essentially **deleting the file and creating a copy in the new location.**
> But - we can still find the previous history of files by using `git log --follow ./filename`. This essentially includes both the
> history for the current file - and the history for the file that was deleted (renamed). This gives the practical effect of having
> full history for a single file, but git is tracking the files pre-rename and post-rename separately.
> For this reason, **it's a good idea to not rename your files too much** as it results in complicated git history.

## Dry runs
using the `--dry-run` option just lets us see a summary of what would happen - good if we aren't sure the best next step.
```
#Show what would happen if we staged all of our changes:
git add . --dry-run
```
---

# Reverting changes

## Rollback file changes
You can use `git restore ./my_file` to discard any changes for a particular file in your working directory. **Be careful you don't lost your changes - use with care!**

Once you have staged your files for commit with `git add` you can UNSTAGE those commits by using `git restore --staged ./myfile` - this will not remove changes to your files, but will just *unstage the changes.*

> **NOTE:** I like the idea of using `git add` as kind of a 'git save' option. As I'm working on my files, I can add my changes as I work. Then, once I make a *cohesive change*, I do a commit.
> If I need to roll back any changes, I can just do a `git restore` on a single file, but I know that it's extra difficult for me to accidentally revert all changes - because I can't revert already staged changes without the --staged option.

## Commit amend
The `git commit --amend` command allows you to add changes to the last commit and update the message. This REPLACES the last commit.
```
git commit --amend -m "added dependencies AND config file"
```

> **NOTE:** When would I want to do this? I guess if I made an actual error with my previous commit, that would be helpful,
> or if I forgot to add some relevant changes to the same commit.

> **NOTE:** Git recommends that you make *relatively small changes* - which are easily rolled back - rather than large, monolithic commits. I'm guessing there's a sweet spot - enough changes so that it's impactful, not so many that it's too big of a single step.

## Commit revert
Reverting the latest commit is relatively easy, but reverting older commits is more difficult.

## Delete untracked files
`git clean` allows you to remove files only if they are **untracked**. It also works recursively for all folders in the git repo. The `-n` option does a dry run, `-f` (force) executes the removal, and `-i` is interactive (more options also exist).

This is convenient relative to `rm` since it (a) works recursively for all folders in a git repo and (b) only removes untracked files.
There may be other advantages too that I'm not yet aware of.

---

# Ignoring files
We want to ignore temporary, sensitive, or infrastructure-related (e.g., virtual envs) files.

## Ignore files
### .gitignore syntax
```
#This is a comment in .gitignore file
#---------------
#--Directories--
#---------------
#Ignore everything in the 'media' folder
media/

#------------------
#--Specific files--
#------------------
*test.mp4

#------------------------
#--Matching expressions--
#------------------------
#Ignore any file ending in '.log'
*.log

#------------
#--Negation--
#------------
#Ignore all log files as specified above, except 'security.log'
!security.log
```

### Ignoring on system or user level;
```
#Make a gitignore file on the system level:
git config --global core.execluesgfile ~/.gitignore_all
```
> NOTE: I don't like the idea of setting too many global values like this - because these other specifications are not being tracked. For example, if I popped down on a new computer and cloned the repo, then I would need to re-set those system-level specs. I think that's not as nice as having every repo be self-contained: having 100% of the information necessary to run and maintain the code.

## Track empty folders
By default, git does **not** track empty folders. Some people (apparently including the trainer of this course) want all of their empty folders to also be tracked. If you want this, you just need to add some dummy file (e.g., an empty `.trackme` file) to the folder and then git will track it.

> I personally much use for this. Git is not for tracking folder structures anyway (as evidenced by its clunky renaming system), and if a folder is empty, I don't see why we need it. Maybe one exception would be if I am collaborating with others and I want to set up a repo structure for us all to use, then I would want to upload the structure. I would definitely use a non-hidden file though (e.g., `dummy-file.txt`)

## Untrack tracked files
Once you track a file in git, it's a little tricky to *stop tracking it*.
The first step is to identify the file in `.gitignore`, but that alone will not stop it from being tracked.
You will also need to remove it from the git cache using `git rm --cached file.txt`. This will keep the file locally, but git will no longer track it.

---

# Git Branches
Git branches are pretty easy to create (relative to other VCS's) and switch between.

## Creating branches
```
# List out branches
git branch

# Create branch
git branch feature_1

# Switch branches
git checkout feature_1

# Create + switch to branch in 1 command
git checkout -b feature_1
```

> NOTE: As you switch between branches, the files in your local directory will update on-the-fly with the latest commit for that particular branch. This makes sense, but it's also a bit surprising to have git modifying your files for you.

## Renaming branches
We would rename branches if we made a mistake or we want to take a previously development branch and make it production
`git branch -m old_branch_name new_branch_name`
A typical professional branch name might be embedded with additional information like: **release_1.1.0_paymentoverhaul**

## Deleting branches
```
#Show which branches are merged into the currently active branch
#If more than 1 branch is shown, we know which branches are fully merged (and could be deleted without losing content)
git branch --merged

#Delete a branch
#If you try to do this with an unmerged branch, you will get a warning when doing this.
git branch -d old_branch
```

## Merging
```
#Compare differences between 2 branches:
git diff branch_1 branch_2

#Merge a given branch into the branch you're currently on.
git merge branch_2
```

> Note: The trainer noted that merging is only easy when the same files are not being edited by 2 different branches - *but this is rarely the case.* Resolving different changes in the same file across branches can be tricky - so the following practices are recommended:
>  1. Pull the latest updates from your primary (production) branch into your branch whenever you start working and before you attempt to merge your branch with the primary branch. Resolve issues locally.
>  2. [Microsoft recommends using feature branches](https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance?view=azure-devops) for all of your bug fixes and new features. They say that since branches are so easy to create and maintain, this is well worth the effort.
>  3. Microsoft also recommends holding to a naming convention for feature branches [such as using folders](https://learn.microsoft.com/en-us/azure/devops/repos/git/require-branch-folders?view=azure-devops&tabs=browser) and insisting on pull requests for reviewing changes and ensuring code quality.

---

# Git tags
Tags are just names associated with specific commits in the repository. This allows us to find them later rather than relying only on commit hashes. For instance, if we have used tags in our commits, and we use `git log` - we will see the tags alongside our commit log and it will be easier to see which commits are related to certain features, bugfixes, etc.

1. Lightweight tags point to a commit hash. This has no meta data
2. Annotated tags also have *meta data* (author's name, release notes, tag-message, date, etc.) and is the preferred tag for public releases.

**NOTE: git tags can only be used once.** A good comparison is chapter titles: you wouldn't use the same one twice. For that reason, **semantic versioning** is often used as a git tagging concept. An application of this would be if we needed to somehow roll back to the last stable version, we could easily identify in our git logs which was the last version because that commit is **tagged as such.**

## Create and list tags
```
#Create a *lightweight* tag
git tag release_tag_v1

#Create an *annotated* tag
git tag -a release_tag_v1

#List tags
git tag

#List tags starting with "rel"
git tag -l rel*

#VERY COOL: Assign a tag to a past commit (do some cleaning of your git history after the fact to make it more manageable).
#End of the line is the start of the commit hash:
git tag -a practice_tag_2 a0d354b
```

Note: everytime you create a tag, it gets assigned to the HEAD of the current branch.

## Delete tags
`git tag -d release_1.0.1`

## Checkout tags & detached HEAD
If you run the command `git checkout` with either a tag name or a commit hash (i.e., some way to identify the commit), then you will start to see and edit files as if you were *on that past commit*. At this stage, you are **not on a branch** - which means you are in a 'detached head' state.
Git tells you once you run this command more about this, but essentially you can play around with making changes and easily discard them, but if you want to actually commit changes, you will need to create a new branch off of this commit that you've checked out.

The danger of working like this is that **if you switch out of this detached head state then all of your commits could be lost**. More specifically, git will warn you that you're leaving some commits behind and give you the hash, but if you don't record this for some reason, you will not be able to find this commit hash - and the commit - later.

---

# Git aliases
These are similar to linux aliases - they're ways to create shortened commands:
```
#Create an alias 's' for 'git status'
git config --global alias.s status

#git status:
git s
```

> Note: I don't hate this, but I'm not sure it's worth it, unless it's for a particularly complex and often-used command (e.g., with lots of options)

> Bonus: Linux Aliases:
> `alias` will show the linux aliases I have in my system.
> `alias gl="git log --oneline"` will make an alias 'gl' to run 'git log'

---

# Remote repo + Commit log filtering

## Cloning a remote repo
```
#Clone a specific git repo:
git clone https://github.com/git/git.git
```

Note: When cloning a repo, use `git log` and `git tag` to find and explore the past commits.

---

## Git log filtering
```
#Get the last 3 commits
git log -3

#Get all commits UP UNTIL a particular tag
git log rel1.0

#Display all commits by authors matching "Kevi"
git log --author="Kevi"

#Find all commits with messages matching 'notes'
git log --oneline --grep="notes"

#Find all commits from commit 'a38c8a3' until current commit (HEAD)
git log --oneline a38c8a3..HEAD

#Find all commits from commit 'a38c8a3' until commit '7b543cc'
git log --oneline a38c8a3..7b543cc

#Find all commits made after April 1, 2023 and before April 21, 2023:
git log --oneline --after="2023-04-01" --before="2023-04-21"
```

## Git log + format options:
```
#Print a shorter git log:
#Other options: full, fuller, raw
git log --format=short

#Print a git log with user emails:
git log --format=email

#Show a visual graph of branches
git log --graph
```

---

# Extras

## Git Completion (optional)
Git completion is an optional - but handy tool that allows you to use the 'tab' key to auto-complete your git commands in the terminal.
Source code found here: https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
By copying this bash into our `/usr/share/bash-completion/completions` folder, we can get this file to run whenever we run a terminal - and therefore allow completion of our git commands.

```
#Download git completion file and save it in a random folder (made a bash_custom folder on home for convenience)
curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.bash_custom/.git-completion.bash
```

## Git Configuration
There are 3 levels of git configuration:
- System: `/etc/gitconfig`
  - We can set system config with `git config --system`
- User: `~/.config/git/config` or `~/.gitconfig`
  - We can set user config with `git config --global`
- Project: `.git/config`
  - We can set project config with `git config --local`

```
#List out user config:
git config --global -l

#List out project config:
git config --global -l

#List out all configurations:
git config -l
```

**Some commonly set configurations and what they mean:**
- user.email = what email will be used to sign off your git commits
- core.editor = base core editor. If you don't enter a commit message, for example, git will open this editor and ask you to enter the commit message there.

---

## Git commit messages best practices
Adding a sufficient level of detail to commit messages helps you navigate the commit log later on.
- Poor message: `"updated resources.txt file"`
  - This message says nothing about what changes were actually made - and git will already record which files were edited, so this adds no new information
- O.k. message: `"added 'fastAPI' and 'datetime' module dependencies to resources.txt file"`
  - This message says more specifically what we are doing - already making it easier to look through the commit log and see the flow of changes
- Good message: `"Jira#12003 added 'fastAPI' and 'datetime' module dependencies to resources.txt file"`
  - If we are working on a specific project or issue, we can and should reference the name of that in our commit - this makes it much easier to find and filter all of the commits related to specific tickets.
